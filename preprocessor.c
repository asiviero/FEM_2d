/*
 * preprocessor.c
 *
 *  Created on: Jan 4, 2012
 *      Author: andre
 *      Modulo responsavel pelo pre-processamento do programa. Deve realizar as seguintes opera√ßoes:
 *      - Ler numero de nos (nNodes), numero de elementos (nEl), constantes fisicas (kx, ky, bx, by, sigma, f, g, h),
 *      dados sobre a malha e dados para o metodo de solucao do sistema linear
 *      - Geracao de malha utilizando o EasyMesh - ok
 *      - Montagem da Conectividade dos Elementos - ok
 *      - Leitura das Condicoes de Contorno - ok
 *      - Definicao de nos prescritos e incognitas
 */

#include "preprocessor.h"

void debug() { printf("passei!\n");}
void generateMesh(char *meshFile) {
	int pid;
	pid = fork();
	if(pid == 0) {
		execlp("EasyMesh","EasyMesh",meshFile,"+dxf");
	}
	else wait();
}

node* scanNodes(char *nodeFile,int *nNodes) {
	FILE *nodeFileP;
	node *nodeVector;
	nodeFileP = fopen(nodeFile,"r");
	fscanf(nodeFileP,"%d",nNodes);
	printf("nNodes: %d\n",*nNodes);
	nodeVector = (node*)malloc((*nNodes)*sizeof(node));

	for(int i=0;i<*nNodes;i++) {
		fscanf(nodeFileP,"%d: %lf %lf %lf",&nodeVector[i].id,&nodeVector[i].x,&nodeVector[i].y,&nodeVector[i].z);
	}

	fclose(nodeFileP);
	return nodeVector;
}

void applyContour(int cid,int nNodes,node *nodeVector,void(*func)(node *n)) {
	for(int i=0;i<nNodes;i++) {
		if(nodeVector[i].z==cid) func(&nodeVector[i]);
	}
}

element* scanElements(char *elementFile,int *nElements) {
	FILE *elementFileP;
	element *elementVector;
	elementFileP = fopen(elementFile,"r");
	fscanf(elementFileP,"%d",nElements);
	printf("nElements: %d\n",*nElements);
	elementVector = (element*)malloc((*nElements)*sizeof(element));
	int eid,n1,n2,n3,garbage;
	float fgarbage;

	for(int i=0;i<*nElements;i++) {
		fscanf(elementFileP,"%d: %d %d %d %d %d %d %d %d %d %lf %lf %d",&elementVector[i].eid,&elementVector[i].n1,&elementVector[i].n2,&elementVector[i].n3,&garbage,&garbage,&garbage,&garbage,&garbage,&garbage,&fgarbage,&fgarbage,&garbage);
		//printf("Elemento %d composto pelos nodes %d, %d e %d\n",elementVector[i].eid,elementVector[i].n1,elementVector[i].n2,elementVector[i].n3);
	}
	fclose(elementFileP);
	return elementVector;
}

int* buildIDArrangement(node *nodeVector, int nNodes, int *nEq) {
	int id_counter=0;
	int *idArrangement;
	idArrangement = (int*)calloc(nNodes,sizeof(int));
	for(int i=0;i<nNodes;i++) {
		if(nodeVector[i].z == 0) idArrangement[i] = ++id_counter;
		else idArrangement[i] = 0;
	}
	*nEq = id_counter;
	return idArrangement;
}


int main(int argc,char **argv) {
	if(argc!=2) {
		printf("\nUsage: ./FEM_2d meshfile.d\n\n");
		exit(1);
	}
	int *nNodes,*nElements,*nEq;
	printf("Generating Mesh...\n");
	/*
	 * Manipulacao de Strings relativas a nomes de arquivos
	 */
	char baseMeshName[50],nodeFile[52],elementFile[52];
	strcpy(baseMeshName,argv[1]);
	strcpy(nodeFile,baseMeshName);
	strcpy(elementFile,baseMeshName);
	strcat(nodeFile,".n");
	strcat(elementFile,".e");
	generateMesh(argv[1]);
	printf("Alright, mesh supposedly generated...\n");
	/*
	 * Nodes are gonna be stored in a vector dinamically allocated, which is gonna be freed after
	 * the nodes are put in a list as elements, grouped in "triangles".
	 *
	 * Node file: argv[1].n
	 */
	printf("\nGenerating Node Vector...\n");
	node *nodeVector;

	nodeVector = scanNodes(nodeFile,&nNodes);
	debug();
	for(int i=0;i<10;i++) printf("%d: %lf %lf %lf\n",nodeVector[i].id,nodeVector[i].x,nodeVector[i].y,nodeVector[i].z);
	//nNodes = *nNodesP;
	printf("nNodes: %d\n",nNodes);

	/*
	 * Now, the nodes must be grouped in triangular elements. A vector of 3-element generic list will be used
	 * for this, in a similar way to what has been done with the node vector
	 */
	element *elementVector;
	elementVector = scanElements(elementFile,&nElements);

	/*
	 * After grouping, the ID arrangement is done.
	 *
	 * The ID arrangement is an array which has the same number of elements as the number of nodes.
	 * For each node, an integer is assigned, being 0 for prescripted nodes and j for incognite nodes,
	 * in a manner that j starts in 1 and goes until nEq, which is the number of equations that will
	 * come up in the linear system associated to the problem.
	 */
	int *idArrangement;
	idArrangement = buildIDArrangement(nodeVector,nNodes,&nEq);
	printf("ID Arrangement:\n\n");
	for(int i=0;i<10;i++) printf("%d: %d\n",i,idArrangement[i]);
	printf("\nNumber of equations: %d\n",nEq);

	/*
	 * Next, contour conditions are gonna be applied.
	 *
	 * Since the code can't know beforehand how many contour conditions exist or how they are,
	 * a single function "applyContour" must be called as many times as needed, using as parameters
	 * the Node Vector, the number of nodes, a contour id (as it's generated by EasyMesh) and a
	 * callback function, which is defined in the contourFunction.c file. It's again stressed that
	 * this area of the code will require modification in order to be used for any specific problem
	 * and contour condition.
	 *
	 */
	applyContour(1,nNodes,nodeVector,testF);
	/*
	 * Add as many Contour conditions needed here
	 */
	for(int i=0;i<10;i++) printf("%d: %lf %lf %lf\n",nodeVector[i].id,nodeVector[i].x,nodeVector[i].y,nodeVector[i].z);

	/*
	 * Now we perform the elementary calculus needed
	 */
	double JMatrix[2][2];

	calculateJMatrix(0,nodeVector,elementVector,JMatrix);
	printf("\n\n test: %lf\n",JMatrix[0][0]);
	printf("test: %lf\n",JMatrix[0][1]);
	printf("test: %lf\n",JMatrix[1][0]);
	printf("test: %lf\n",JMatrix[1][1]);

	double KeMatrix[3][3];
	double I[2][2];
	I[0][0] = 1;
	I[0][1] = 0;
	I[1][0] = 0;
	I[1][1] = 1;

	calculateKeMatrix(0,nodeVector,elementVector,KeMatrix,I);
	printf("Matriz Ke:\n\n");
	for(int i=0;i<3;i++) {
		for(int j=0;j<3;j++) printf("%lf ",KeMatrix[i][j]);
		printf("\n");
	}




	free(nodeVector);
	free(elementVector);
	return 0;
}


















